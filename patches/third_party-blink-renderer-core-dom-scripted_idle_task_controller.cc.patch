diff --git a/third_party/blink/renderer/core/dom/scripted_idle_task_controller.cc b/third_party/blink/renderer/core/dom/scripted_idle_task_controller.cc
index 2364cc22b0563939fbf16ad10ef651c0b4f731f6..b5e1010faf99a7a87e76784e7fabd4f469b880a4 100644
--- a/third_party/blink/renderer/core/dom/scripted_idle_task_controller.cc
+++ b/third_party/blink/renderer/core/dom/scripted_idle_task_controller.cc
@@ -19,62 +19,6 @@
 
 namespace blink {
 
-namespace internal {
-
-class IdleRequestCallbackWrapper
-    : public RefCounted<IdleRequestCallbackWrapper> {
- public:
-  static scoped_refptr<IdleRequestCallbackWrapper> Create(
-      ScriptedIdleTaskController::CallbackId id,
-      ScriptedIdleTaskController* controller) {
-    return base::AdoptRef(new IdleRequestCallbackWrapper(id, controller));
-  }
-  virtual ~IdleRequestCallbackWrapper() = default;
-
-  static void IdleTaskFired(
-      scoped_refptr<IdleRequestCallbackWrapper> callback_wrapper,
-      base::TimeTicks deadline) {
-    if (ScriptedIdleTaskController* controller =
-            callback_wrapper->Controller()) {
-      // If we are going to yield immediately, reschedule the callback for
-      // later.
-      if (ThreadScheduler::Current()->ShouldYieldForHighPriorityWork()) {
-        controller->ScheduleCallback(std::move(callback_wrapper),
-                                     /* timeout_millis */ 0);
-        return;
-      }
-      controller->CallbackFired(callback_wrapper->Id(), deadline,
-                                IdleDeadline::CallbackType::kCalledWhenIdle);
-    }
-    callback_wrapper->Cancel();
-  }
-
-  static void TimeoutFired(
-      scoped_refptr<IdleRequestCallbackWrapper> callback_wrapper) {
-    if (ScriptedIdleTaskController* controller =
-            callback_wrapper->Controller()) {
-      controller->CallbackFired(callback_wrapper->Id(), base::TimeTicks::Now(),
-                                IdleDeadline::CallbackType::kCalledByTimeout);
-    }
-    callback_wrapper->Cancel();
-  }
-
-  void Cancel() { controller_ = nullptr; }
-
-  ScriptedIdleTaskController::CallbackId Id() const { return id_; }
-  ScriptedIdleTaskController* Controller() const { return controller_; }
-
- private:
-  IdleRequestCallbackWrapper(ScriptedIdleTaskController::CallbackId id,
-                             ScriptedIdleTaskController* controller)
-      : id_(id), controller_(controller) {}
-
-  ScriptedIdleTaskController::CallbackId id_;
-  WeakPersistent<ScriptedIdleTaskController> controller_;
-};
-
-}  // namespace internal
-
 ScriptedIdleTaskController::ScriptedIdleTaskController(
     ExecutionContext* context)
     : ExecutionContextLifecycleStateObserver(context),
@@ -114,31 +58,36 @@ ScriptedIdleTaskController::RegisterCallback(
   idle_task->async_task_context()->Schedule(GetExecutionContext(),
                                             "requestIdleCallback");
 
-  scoped_refptr<internal::IdleRequestCallbackWrapper> callback_wrapper =
-      internal::IdleRequestCallbackWrapper::Create(id, this);
-  ScheduleCallback(std::move(callback_wrapper), timeout_millis);
+  ScheduleCallback(id, timeout_millis);
   DEVTOOLS_TIMELINE_TRACE_EVENT_INSTANT(
       "RequestIdleCallback", inspector_idle_callback_request_event::Data,
       GetExecutionContext(), id, timeout_millis);
   return id;
 }
 
-void ScriptedIdleTaskController::ScheduleCallback(
-    scoped_refptr<internal::IdleRequestCallbackWrapper> callback_wrapper,
-    uint32_t timeout_millis) {
-  scheduler_->PostIdleTask(
-      FROM_HERE,
-      WTF::BindOnce(&internal::IdleRequestCallbackWrapper::IdleTaskFired,
-                    callback_wrapper));
+void ScriptedIdleTaskController::ScheduleCallback(CallbackId id,
+                                                  uint32_t timeout_millis) {
   if (timeout_millis > 0) {
-    GetExecutionContext()
-        ->GetTaskRunner(TaskType::kIdleTask)
-        ->PostDelayedTask(
-            FROM_HERE,
-            WTF::BindOnce(&internal::IdleRequestCallbackWrapper::TimeoutFired,
-                          callback_wrapper),
-            base::Milliseconds(timeout_millis));
+    auto callback = WTF::BindOnce(&ScriptedIdleTaskController::TimeoutFired,
+                                  WrapWeakPersistent(this), id);
+    base::DelayedTaskHandle delayed_task_handle =
+        GetExecutionContext()
+            ->GetTaskRunner(TaskType::kIdleTask)
+            ->PostCancelableDelayedTask(base::subtle::PostDelayedTaskPassKey(),
+                                        FROM_HERE, std::move(callback),
+                                        base::Milliseconds(timeout_millis));
+
+    scheduler_->PostIdleTask(
+        FROM_HERE,
+        WTF::BindOnce(&ScriptedIdleTaskController::IdleTaskFiredWithHandle,
+                      WrapWeakPersistent(this), id,
+                      std::move(delayed_task_handle)));
+
+    return;
   }
+  scheduler_->PostIdleTask(
+      FROM_HERE, WTF::BindOnce(&ScriptedIdleTaskController::IdleTaskFired,
+                               WrapWeakPersistent(this), id));
 }
 
 void ScriptedIdleTaskController::CancelCallback(CallbackId id) {
@@ -148,9 +97,34 @@ void ScriptedIdleTaskController::CancelCallback(CallbackId id) {
   if (!IsValidCallbackId(id))
     return;
 
+
   idle_tasks_.erase(id);
 }
 
+void ScriptedIdleTaskController::IdleTaskFired(CallbackId id,
+                                               base::TimeTicks deadline) {
+  // If we are going to yield immediately, reschedule the callback for
+  // later.
+  if (ThreadScheduler::Current()->ShouldYieldForHighPriorityWork()) {
+    ScheduleCallback(id, /* timeout_millis */ 0);
+    return;
+  }
+  CallbackFired(id, deadline, IdleDeadline::CallbackType::kCalledWhenIdle);
+}
+
+void ScriptedIdleTaskController::IdleTaskFiredWithHandle(
+    CallbackId id,
+    base::DelayedTaskHandle handle,
+    base::TimeTicks deadline) {
+  IdleTaskFired(id, std::move(deadline));
+  handle.CancelTask();
+}
+
+void ScriptedIdleTaskController::TimeoutFired(CallbackId id) {
+  CallbackFired(id, base::TimeTicks::Now(),
+                IdleDeadline::CallbackType::kCalledByTimeout);
+}
+
 void ScriptedIdleTaskController::CallbackFired(
     CallbackId id,
     base::TimeTicks deadline,
@@ -234,25 +208,19 @@ void ScriptedIdleTaskController::ContextUnpaused() {
   // Run any pending timeouts as separate tasks, since it's not allowed to
   // execute script from lifecycle callbacks.
   for (auto& id : pending_timeouts_) {
-    scoped_refptr<internal::IdleRequestCallbackWrapper> callback_wrapper =
-        internal::IdleRequestCallbackWrapper::Create(id, this);
     GetExecutionContext()
         ->GetTaskRunner(TaskType::kIdleTask)
-        ->PostTask(
-            FROM_HERE,
-            WTF::BindOnce(&internal::IdleRequestCallbackWrapper::TimeoutFired,
-                          callback_wrapper));
+        ->PostTask(FROM_HERE,
+                   WTF::BindOnce(&ScriptedIdleTaskController::TimeoutFired,
+                                 WrapWeakPersistent(this), id));
   }
   pending_timeouts_.clear();
 
   // Repost idle tasks for any remaining callbacks.
   for (auto& idle_task : idle_tasks_) {
-    scoped_refptr<internal::IdleRequestCallbackWrapper> callback_wrapper =
-        internal::IdleRequestCallbackWrapper::Create(idle_task.key, this);
     scheduler_->PostIdleTask(
-        FROM_HERE,
-        WTF::BindOnce(&internal::IdleRequestCallbackWrapper::IdleTaskFired,
-                      callback_wrapper));
+        FROM_HERE, WTF::BindOnce(&ScriptedIdleTaskController::IdleTaskFired,
+                                 WrapWeakPersistent(this), idle_task.key));
   }
 }
 
